# ecommerce-project

## 프로젝트 개요
이커머스 플랫폼들의 주요 기능을 이해하고 구현해보았습니다.

특히 이 프로젝트에서, 동시에 여러 사용자가 상호작용하는 환경에서 발생할 수 있는 동시성 문제 및 상품의 삭제 및 업데이트와 관련된 여러 정책들에 대해 고민을 해보았고, 이러한 문제 상황들을 해결하기 위해 기본적인 지식과 방법을 습득하고, 적용해 보았습니다. 

이를 통해 이커머스 플랫폼 개발에서 고려해야 할 여러가지 이슈에 대한 이해를 높이고, 실제 서비스 환경에서 발생하는 문제들에 대한 해결하는 능력을 키우는 것이 해당 프로젝트의 목표입니다.

---

## 기술 스택
- Spring Boot
- JPA
- Maria DB
- Redis(시간 남을 시)
- Spring Security(JWT)

---

## 프로젝트 주요 기능
(구현 이후 url 및 메서드에 따라 세분화 하여 작성할 예정, 로그인과 회원가입에 JWT를 적용해본적이 없어서 해보고 싶지만, 우선 로직 구현을 우선으로 두자!)

### 회원 가입 API
- 입력 정보(이름, 전화번호, 패스워드 등)를 바탕으로 회원 가입
- Spring Security의 BCyptPasswordEncoder를 통해 암호화하여 DB에 패스워드 저장

### 로그인 API
- 이메일, 비밀번호를 바탕으로 로그인
- 로그인 성공 시 JWT 발행
- 토큰 안에 포함되어있는 Role(판매자, 구매자)을 바탕으로 접근(or 요청) 권한 제어

### 회원 API
- 회원 정보 수정
- 회원 탈퇴

### 판매자 API
- 입력 정보(상품 이름 및 설명, 상품 가격, 재고 등)를 바탕으로 상품 등록
- 상품 수정 및 삭제 기능
- 상품 조회(등록 일자, 판매 수량 등)

### 구매자 API
- 잔액 충전
- 상품 주문
- 주문 내역 조회
- 주문 전체 취소 혹은 특정 상품 구매 취소 기능 구현

### 상품 검색 API
- 가격(얼마 이상, 얼마 이하), 최신 등록 상품, 판매량, 카테고리 별로 조회 기능(페이징 처리 필요)

---

## 동시성 문제들

### 1 (상품 구매 요청이 한꺼번에 들어올떄)
예를들어 특정 이벤트 상품(ex: 한정판 노트북)이 판매되는데, 이 상품은 오픈시 총 100개의 재고가 있었고, 99개가 팔린 상황이라 가정해보자.
이 시점에서 두 명의 구매자가 거의 동시에 이 상품을 구매하려고 시도함. 시스템은 구매 요청이 들어올 때마다 재고를 확인하고, 재고가 있을 경우에만 구매를 처리.

하지만, 이 두 구매 요청이 거의 동시에 발생했을때, 시스템이 각 요청을 처리하는 시간 차이가 매우 작아서, 두 요청이 모두 재고가 1개 남았다는 상황에서 처리되는 문제가 발생할 수 있음.

위와 같은 상황에서는 두개의 동시 요청이 동시에 처리되어서는 안됨. 즉, 한 번에 하나의 구매 요청만 처리해야 함
이를 위해 동시성 제어를 어떻게 할지에 대한 고민이 필요 

(단순하게 한다면 SERIALIZABLE 격리 레벨 수준을 사용하여, 한번에 한개의 트랜잭션만 처리되도록 함으로서 이 문제가 해결 가능할 것 -> 트랜잭션 격리 수준의 경우 Repeatable Read를 통해서도 가능할지 고민해보자)

하지만 더 적합한 것은 디비에 락을 거는 것으로 보임
(주문 로직 -> 한 메서드 내에서 우선 product에서 stockNumber를 조회 한 후, 제고가 1보다 크다면 제고를 하나 다운시키고, OrderService를 통해 정상적으로 주문이 진행되게끔)

JPA에 Pessimistic Concurrency Control(Optimistic과 다르게 충돌이 많을 경우 유용)을 위한 옵션이 있음 이를 잘 적용해보자!

이를 어디에 적용해야 할까, (orderProduct, 즉 메서드 단에 건다면 우선 @Synchronized가 있다는 점 생각)

example)

```java
public interface ProductRepository extends JpaRepository<Product,Long>{
  @Lock(LockType.PESSIMISTIC_WRITE)
  Optional<Product> findById(Long id);
}

void orderProduct(Long productId){
  // 제품 찾으면서 락을 검    
    Product product = productRepsoitory.findById(productId).
        orElseThrow(() -> new RuntimeException("not found"));


   if(product.getStockNumber() <= 0){
     throw new RuntimeException("out of stock")
   }
  
   product.decreaseStock();
   productRepository.save(product);
  
   orderRepository.save(order);
}
```

위와 같이 구현했다면 한 제품의 주문 완료떄까지 다른 트랜잭션은 findById()메서드를 실행할 수 없음

위 경우 우선 자주 조회하는 재고를 매번 디비에 조회하러 들어간다는 자체가 성능상으로 안좋아보일 뿐 아니라, 동시성 또한 매우 낮아보임... (이부분은 차차 해결해보자 ex:Redis)

### 2 (동시 판매에 따른 판매자의 balance 업데이트)

예를들어 판매자가 상품 A(가격 100원)와 상품 B(가격 200원)를 동시에 판매했다고 가정해보자.(현재 잔고 0)
정상적인 상황이라면 두개가 동시에 팔렸을때 300원을 벌었어야 함

하지만 만약 A의 판매와 B의 판매에서 잔고 업데이트가 동시에 이루어지면, 각 트랜잭션 둘다 초기 잔고를 0달러로 가정하고 계산을 시작할 수 잇음.

이러한 동시성 문제도 1번 상황과 비슷해 보임, 그런데 각각의 판매에 대한 수익을 별도의 테이블에 기록하고, 이 테이블을 정보를 기반으로 잔고를 계산하면 잔고 업데이트를 위한 트랜잭션 수를 줄일 수 있다는 말도 있음..(이러한 해결방식이 가능하다면 알아보자)


### 3 (구매자 잔고 경우)

만약 구매자가 100달러의 충전 금액을 가지고 있고 동시에 두건의 60달러짜리(각각 다른 제품 이라 가정) 상품을 구매하려는 경우도 있을 수 있음

(근데 직관적으로 딱 보았을때는 보통 같은 상품이라면 장바구니에 여러개 담아서 주문할것 같긴 함)

이 또한 구매자의 충전 금액에 락을 걸어서 해결할 수 있을듯..

---

## 정책적 문제들

### 1. 상품 삭제
구매가 완료된 후에 상품을 삭제하는 것은 문제를 발생시킬 수 있음. 

예를 들어, 판매자가 구매가 완료된 후에 상품을 삭제하게 되면, 구매자 입장에서는 거짓 구매가 발생한 것이므로 이를 방지해 주어야 함. 

따라서, 구매가 일어난 후에는 상품의 삭제를 방지하거나, 삭제시 별도의 안내를 통해 사용자에게 알려주는 방식이 있음
-> 우선은 구매가 일어난 후 상품의 삭제를 방지할 예정

### 2. 상품 수정
상품 구매 당시의 상품 정보들 (ex: 상품 가격, 상품 이름 등)을 저장하기 위해 따로 테이블을 둘 에정

(이후 상품 정보가 수정되었을때, 구매자의 주문 정보까지 바뀔 경우를 막기 위해)

### 3. 회원 탈퇴 시
만약 구매자 회원이 탈퇴한 경우, 탈퇴 하더라도 회원의 주문 정보를 남겨둘 필요가 있을지?

판매자 회원이 탈퇴할 경우, 탈퇴 하더라도 회원이 지금 까지 판매를 위해 등록했던 상품 정보를 남길 필요가 있을지?? 고민해보자

(우선은 필요할 수 있으니 둘다 남긴다는 정책으로 하자)

---

## 시간이 남을때 해볼만한 것들

- 사용자가 상품을 구매한 후 리뷰를 남기거나 평점을 매기는 시스템 구현
- 단순 구매 취소 뿐 아니라, 배송과 관련된 API를 구현하고(판매자쪽), 배송이 완료되었을때 사용자가 상품을 반품하거나 환불을 요구하는 경우 어떻게 처리할지도 고민해볼만 함
- 장바구니 기능 구현

---
## ERD

![스크린샷 2023-07-17 오전 11 11 45](https://github.com/wookjongkim/ecommerce-project/assets/121083077/24464f98-7b9f-42e4-8f8a-71772cf5c3b9)









